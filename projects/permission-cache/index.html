<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><title>Jack Greenberg | Redis Permission Cache</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=title content="Jack Greenberg"><meta name=description content="The portfolio and personal website for Jack Greenberg. I'm an electrical and firmware engineer studying at Olin College of Engineering."><meta itemprop=name content="Jack Greenberg"><meta itemprop=description content="The portfolio and personal website for Jack Greenberg. I'm an electrical and firmware engineer studying at Olin College of Engineering."><meta itemprop=image content="/images/portrait_hu2ba8ed41c5e8f766e39c586334c20da3_2485738_600x0_resize_box_2.png"><meta property="og:type" content="website"><meta property="og:url" content="https://www.jackgreenberg.co"><meta property="og:title" content="Jack Greenberg"><meta property="og:description" content="The portfolio and personal website for Jack Greenberg. I'm an electrical and firmware engineer studying at Olin College of Engineering."><meta property="og:image" content="/images/portrait_hu2ba8ed41c5e8f766e39c586334c20da3_2485738_600x0_resize_box_2.png"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://www.jackgreenberg.co"><meta property="twitter:title" content="Jack Greenberg"><meta property="twitter:description" content="The portfolio and personal website for Jack Greenberg. I'm an electrical and firmware engineer studying at Olin College of Engineering."><meta property="twitter:image" content="/images/portrait_hu2ba8ed41c5e8f766e39c586334c20da3_2485738_600x0_resize_box_2.png"><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=manifest href=/favicons/site.webmanifest><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=Fira+Sans:wght@400;500;600;700&display=swap" rel=stylesheet><link rel=stylesheet href=/style.index.min.c57673b1ad49e8bf27d8e158d6a0835d4cfa6dd5f20a164edf90b9da3453ce33.min.c57673b1ad49e8bf27d8e158d6a0835d4cfa6dd5f20a164edf90b9da3453ce33.css integrity="sha256-xXZzsa1J6L8n2OFY1qCDXUz6bdXyChZO35C52jRTzjM="></head><body><div class=Page><header class="Header vertical-flex__shrink"><p class=Header__title><a href=/>Jack Greenberg</a></p><label for=nav-trigger class=nav-trigger>[]</label>
<input type=checkbox id=nav-trigger><nav class=nav><label for=nav-trigger class=nav-overlay></label><p class=nav__homelink><a href=/>Jack Greenberg</a></p><ul class=nav__list><li class=nav__list__link><a href=/projects>Projects</a></li><li class=nav__list__link><a href=/about>About</a></li><li class=nav__list__link><a href=/documents/resume.pdf>Resume</a></li></ul></nav></header><div class=vertical-flex><main class="Content vertical-flex__fill PageWidth"><div class=Content__backlink><a href=/projects>&lt; Back to projects</a></div><h1>Redis Permission Cache
<img class=project-image src=images/main.svg></h1><p>During my summer internship at <a href=https://indico.io>Indico</a>, one of my big projects was building a cross-microservice permission cache system using Redis.</p><p>Indico&rsquo;s API is a microservices architecture, which means that they have a bunch (~12 iirc<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>) of smaller applications that all communicate over HTTP to perform different functions. For instance, one service fetches datasets from a database while others handle that data and perform machine learning tasks.</p><p>The need for a permission cache came from the fact that when any of these services were used (i.e. they received an HTTP request), each of them <em>individually</em> would have to make sure that the request had the correct permissions on the data that was being used.</p><p>And in order to verify those permissions, the service in question would have to make an <em>additional</em> HTTP request to a central service that was responsible for verifying the permissions. So for each request, there would be almost double the amount of HTTP traffic, and for large, involved requests, that could mean a very heavy load for the whole system.</p><p>That&rsquo;s where my project came in.</p><p>Each of the services has access to a central in-memory database that runs <a href=https://redis.io/>Redis</a>. Utilizing Redis I was able to write a system where only a <em>single</em> service has to make an HTTP request, and the others just wait for the first one to fetch the data, and read it from Redis. It works like this:</p><ol><li>3 services {A, B, C} need to verify permissions on a set of data.</li><li>The first service to query the cache <em><strong><code>A</code></strong></em> sees that it is unlocked and empty, and locks it.<ul><li>Any other service that checks the cache now will see that it is locked, so it can just wait</li></ul></li><li><em><strong><code>A</code></strong></em> makes an HTTP request to fetch the permissions, and then stores the results in Redis.</li><li><em><strong><code>A</code></strong></em> then unlocks the cache</li><li>Now all other services that were waiting for the lock to be released are now able to access the cache, and find that it is filled with data that they can use.</li></ol><h2 id=design-decisions>Design Decisions</h2><p>There were a handful of decisions that were made to improve the performance and security of the tool. For one, each cache was keyed<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> using the API request ID, the user id, and the data id. This meant that the data was only fresh for a specific request and a specific user, and thus wouldn&rsquo;t be accessed by any others.</p><p>Additionally, we set up a number of failsafes that would prevent deadlocks, including a timeout on the cache lock, just to make sure that a request never failed due to a fault in a single service.</p><p>One option we considered while designing the system was actually moving all permissions to a Redis database instead of having them fetched per HTTP request. While potentially memory-intensive, this option would be beneficial in that it would prevent race conditions with different microservices making simultaneous requests, and instead just allow the services to make requests to Redis directly, thus eliminating HTTP traffic in that stage entirely.</p><h2 id=looking-back>Looking Back</h2><p>This was my first real industry software engineering project, and I learned a lot! It was a great opportunity to apply concepts I learned in my <em>Software Systems</em> class like mutexes and memory storage. It also taught me a lot about software design patterns and writing efficient software.</p><p>I couldn&rsquo;t have done it without the help of my brilliant and patient mentors at Indico, to whom I&rsquo;m forever grateful for the opportunity. I can definitely see that this project and others that I worked on at Indico have changed the way I write software for the better.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>&ldquo;If I remember correctly&rdquo;&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Stored under the name of&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><footer class="footer vertical-flex__shrink PageWidth"><p>©2020 • v2.0 • Powered by Hugo • <a href=https://github.com/jack-greenberg/jack-greenberg.github.io>c3537e7</a> • <a href=/note>Quick Note</a></p></footer></div></div></body></html>