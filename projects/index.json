{"data":[{"title":"Controller Area Network Software Update","date":"2021-10-06 13:11:47 -0400 EDT","year":"2021","draft":"false","featured":"true","image":"<no value>","permalink":"https://www.jackgreenberg.co/projects/can-software-update/index.json","content":"\nOn Olin's Formula SAE team, I built a [vehicle software update\nsystem](https://github.com/jack-greenberg/btldr) consisting\nof a custom bootloader and an application protocol that uses the CAN protocol\nfor its physical and data-link layer.\n\n\u003c!--more--\u003e\n\n{{\u003cimg\n    src=\"images/state.png\"\n    caption=\"State diagram for the software update system\"\n\u003e}}\n\n## Features\n\nThe system, referred to as _btldr_, allows engineers to update any ECU on the\nvehicle without physical access to the hardware. The bootloader is responsible\nfor initializing the CAN protocol stack and reacting to the commands issued by\nthe host. It also handles image validation by performing a cyclic-redunancy\ncheck and refusing to run the image if corruption has occured.\n\nThe entire bootloader takes up less than 4 kilobytes of space on the\ndevice, making it light-weight while still maintaining robustness.\n\n## Application Protocol\n\nThe _btldr_ utilizes a custom protocol for initializing and conducting the\nupdate. There are 4 different message types:\n\n* __Ping__: Checks device reachability, current firmware version, and updater\n  compatibility\n* __Request Update__: Initialize an update session for a particular ECU\n* __Data__: Contains a chunk of the binary being flashed\n* __Reset__: Instructs the device to check the validity of the image and begin\n  executing if it is valid\n\nEach of these commands has an associated response message that is sent by the\ntarget device to acknowledge and/or provide additional data to the host.\n\n## Bootloader\n\nThe bootloader portion of the system is a 4 kilobyte program that executes\nwhenever the device resets. It first checks an EEPROM memory bank that is shared\nwith the application section to see if an update has been requested, and, if so,\ninitializes the protocol stack.\n\nIt then listens for specific CAN messages and acts according to the commands it\nreceives.\n\n## Motivation\n\nHistorically on the Formula team, ECU firmware updates required a group of\nengineers to open up various enclosures and unplug PCBs from around the car and\nmanually recompile and flash code using a programming dongle. This is highly\ninefficient and costs valuable time to the engineers. The motivation behind this\nproject is to provide a streamlined method for updating vehicle firmware that\nonly requires a single point of physical access to the car.\n\n## Future Steps\n\nMany automotive OEMs are recognizing a need for over-the-air (OTA) software\nupdates, especially as more and more embedded systems for electric vehicles are\nbeing introduced for things like safety and autonomy. As a learning experiment,\nI hope to integrate a Wi-Fi-based OTA updater component to the vehicle, which\nwould allow it to be updated remotely.\n\nWith the addition of remote access comes the necessity for security. An\nunsecured software update mechanism could allow malicious actors to introduce\ndangerous code to a vehicle. In addition to wireless access, I also hope to\ncreate a secure software update system which uses code-signing to verify the\nintegrity and origin of the code.\n\n---\n\nDetailed project documentation---including deep-dives into the different\ntechnologies and methods used to build the tool---can be found\n[here](https://docs.olinelectricmotorsports.com/share/01350eeb-8337-4c31-98f8-7eeb97936000).\n"},{"title":"Redis Permission Cache","date":"2020-09-19 11:22:11 -0700 -0700","year":"2020","draft":"false","featured":"false","image":"images/main.svg","permalink":"https://www.jackgreenberg.co/projects/permission-cache/index.json","content":"\nDuring my summer internship at [Indico](https://indico.io), one of my big projects was building a cross-microservice permission cache system using Redis.\n\n\u003c!--more--\u003e\n\nIndico's API is a microservices architecture, which means that they have a bunch (~12 iirc[^1]) of smaller applications that all communicate over HTTP to perform different functions. For instance, one service fetches datasets from a database while others handle that data and perform machine learning tasks.\n\n[^1]: \"If I remember correctly\"\n\nThe need for a permission cache came from the fact that when any of these services were used (i.e. they received an HTTP request), each of them _individually_ would have to make sure that the request had the correct permissions on the data that was being used.\n\nAnd in order to verify those permissions, the service in question would have to make an _additional_ HTTP request to a central service that was responsible for verifying the permissions. So for each request, there would be almost double the amount of HTTP traffic, and for large, involved requests, that could mean a very heavy load for the whole system.\n\nThat's where my project came in.\n\nEach of the services has access to a central in-memory database that runs [Redis](https://redis.io/). Utilizing Redis I was able to write a system where only a _single_ service has to make an HTTP request, and the others just wait for the first one to fetch the data, and read it from Redis. It works like this:\n\n1. 3 services {A, B, C} need to verify permissions on a set of data.\n2. The first service to query the cache ___`A`___ sees that it is unlocked and empty, and locks it.\n    * Any other service that checks the cache now will see that it is locked, so it can just wait\n3. ___`A`___ makes an HTTP request to fetch the permissions, and then stores the results in Redis.\n4. ___`A`___ then unlocks the cache\n5. Now all other services that were waiting for the lock to be released are now able to access the cache, and find that it is filled with data that they can use.\n\n## Design Decisions\n\nThere were a handful of decisions that were made to improve the performance and security of the tool. For one, each cache was keyed[^2] using the API request ID, the user id, and the data id. This meant that the data was only fresh for a specific request and a specific user, and thus wouldn't be accessed by any others.\n\n[^2]: Stored under the name of\n\nAdditionally, we set up a number of failsafes that would prevent deadlocks, including a timeout on the cache lock, just to make sure that a request never failed due to a fault in a single service.\n\nOne option we considered while designing the system was actually moving all permissions to a Redis database instead of having them fetched per HTTP request. While potentially memory-intensive, this option would be beneficial in that it would prevent race conditions with different microservices making simultaneous requests, and instead just allow the services to make requests to Redis directly, thus eliminating HTTP traffic in that stage entirely.\n\n## Looking Back\n\nThis was my first real industry software engineering project, and I learned a lot! It was a great opportunity to apply concepts I learned in my _Software Systems_ class like mutexes and memory storage. It also taught me a lot about software design patterns and writing efficient software.\n\nI couldn't have done it without the help of my brilliant and patient mentors at Indico, to whom I'm forever grateful for the opportunity. I can definitely see that this project and others that I worked on at Indico have changed the way I write software for the better.\n"},{"title":"Tools.Olin","date":"2020-05-14 15:55:50 -0700 -0700","year":"2020","draft":"false","featured":"false","image":"<no value>","permalink":"https://www.jackgreenberg.co/projects/tools-olin-edu/index.json","content":"\nDuring the spring of 2020, I worked for the machine shop at Olin to design and build a new web application to manage tool training. The shop at Olin has lots of offerings, from mills and lathes to 3D printers and laser cutters, and all of them have a training that you must go through to be authorized to use the tool.\n\nThe platform that I built provides students and staff a way to sign up for trainings and keep track of their progress, and would allow the machine shop staff to approve trainees and keep tabs on who is authorized to use which tools.\n\nFor the app I used a software stack I've grown to love: Flask for the back-end and routing, ReactJS for the front-end, and PostgreSQL+SQLAlchemy for a database and middleware. I've grown comfortable with this stack, and find it quite powerful.\n\nThe main feature of the site is a single page application that acts as a checklist for students training on a given machine:\n\n{{\u003cimg\n    src=\"images/checklist.png\"\n    caption=\"Mobile view of lathe training checklist.\"\n\u003e}}\n\nFor trainees, it allows you to track your progress, but provides little more than resources and a display. The view is more functional for trainers, or NINJAs[^1]. NINJAs have the power to check off the different boxes, provided that the student has completed the task to the satisfaction and training standards of the shop.\n\n[^1]: _Need Info Now, Just Ask_: Olin's version of course/shop assistants\n\nOne big feature that the shop requested was better accountability of who does what in trainings, and so the application back-end contains a logging system that keeps track of who trained who on what machine at what time. This helps the shop staff keep track of trainings, and if someone has made a mistake, they know who to ask for clarification.\n\nAll administration tasks are accessible from another single page application for admins:\n\n{{\u003cimg\n    src=\"images/admin.png\"\n    caption=\"Admin view that allows administrators to add trainers.\"\n\u003e}}\n\nFeatures of the admin interface include the ability to assign other admins and trainers, export logs targeted to specific tools, trainees, and trainers, and update the tools and training documents.\n\n## Current Status\n\nHaving been ordered to evacuate campus, the work I did on the site was cut short. I had hoped to continue on it during the summer, but circumstances prevented it. When I return next to campus, I will complete work on the site.\n"},{"title":"NEATO Gauntlet","date":"2020-05-13 20:20:30 -0700 -0700","year":"2020","draft":"false","featured":"false","image":"images/gauntlet-contour.svg","permalink":"https://www.jackgreenberg.co/projects/neato-gauntlet/index.json","content":"\nThe objective of this project (the final of my Olin class _Quantitative Engineering Analysis_) was to navigate a simulated Roomba-like robot through a world called __The Gauntlet__, avoiding obstacles (boxes) until finally reaching the goal (cylinder).\n\n{{\u003cimg\n    src=\"images/gauntlet.png\"\n    caption=\"The Gauntlet\"\n\u003e}}\n\n\n## The Code\n\n### RANSAC\n\nThe RANSAC, or *Random Sample Consensus* algorithm is a method of identifying features from a dataset. It works by selecting a set of points and fitting a model to them. The algorithm then separates the original dataset into a set of *inliers*, which are points that fall within a threshold *d* of the model, and a set of *outliers*. The process is repeated *n* times until the algorithm has determined the best fit of the model, and outputs that.\n\nAt this point, RANSAC has output a single feature with a given set of inliers, and so it runs again with the leftover outliers to identify a second set of features, and then a third, and so on, until it has identified all the major features of the data.\n\n#### Fitting Lines\n\nTo fit a line, the algorithm chooses two points:\n\n```matlab\npoints = datasample(data, 2, 'Replace', false);\nP1 = points(1,:); P2 = points(2,:);\n```\n\nIt calculates the vector between these two points and its orthogonal vector, and then for every other point in the dataset, it performs the dot product of the point and the unit orthogonal vector to get the perpendicular distance from the point to the line formed by `P1` and `P2`:\n\n```matlab\nV = P2 - P1;\nV_unit = V./norm(V);\nV_Orth = [-V(2) V(1)];\nV_Orth_unit = V_Orth./norm(V_orth);\n\nperpendicular_distances = (data - P2) * V_Orth_unit';\ninliers = abs(perpendicular_distances) \u003e d; % d is the threshold distance for inliers\n```\n\nIt also finds the biggest gap in the our model, because if it is too big, it should be discarded:\n\n```matlab\nbiggest_gap = max(diff(sort(diffs(inliers,:) * V_unit')));\n```\n\n#### Fitting Circles\n\nFitting circles is more challenging. When fitting lines, it is easy to just find the perpendicular distance from any point to that line, but with circles, I needed to be more clever.\n\nA circle can be defined by three points, so the algorithm chooses 3 points from the dataset and splits them in *x* and *y* components:\n\n```matlab\npoints = datasample(data, 3, 'Replace', false);\nPx = points(:,1); Py = points(:,2);\n```\n\nIt then runs a linear regression in the form of a linear systems of equations to solve for the coefficients of the circle in general form:\n\n```matlab\nA = [Px, Py, ones(size(Px))];\nB  = -Px.^2 - Py.^2;\nc = A \\ B;\n\n% x_c and y_c are the x and y components of the circle's center\nx_c = -c(1)/2;\ny_c = -c(2)/2;\n\n% r is the radius of the circle\nr = sqrt(x_c.^2 + yc.^2 - w(3));\n```\n\nOnce it has the center and radius of the circle, it calculates the distance from any point to the circle by finding the distance to the center of the circle, and subtracts the radius to get the distance from the edge of the circle:\n\n```matlab\ndistance = abs(sqrt((data(:,1) - x_c).^2 + (data(:,2) - y_c).^2) - r);\ninliers = (distance \u003c d);\n```\n\nThere are two issues that initially came up with this implementation:\n\n1. The algorithm would sometimes treat straight lines as arcs of circles with ***huge*** radii, on the scale of 10\u003csup\u003e6\u003c/sup\u003e, and\n2. The circle would identify right angles as arcs of a circle.\n\nTo solve the first issue, since I knew the approximate size of the circle, I ruled out models with radii too far from the goal. That part was easier. The second issue required some more ingenuity.\n\nIn theory, if a set of data points fit a model, then any subset of those points would fit the same model just as well. I used this fact to solve the right-angle fitting issue by performing the RANSAC circle detection once more on the set of inliers generated the first time. If the original fit of a circle was *correct*, then the center and radius of the new circle will be roughly the same. However, if it is a right angle, it is more likely that the center of the newly generated circle will be significantly different from the original, so we can rule it out as a circle.\n\n\n\n### Generating Vector Fields\n\nNow that I had a set of boundaries and a goal from our dataset, I needed a way to generate a map that the NEATO can follow. For this challenge, I implemented a vector field/gradient descent algorithm to have the NEATO navigate the gauntlet. To generate the map, I used the equation:\n\n{{\u003ckatex display \u003e}}\nz = ln \\sqrt{(x-x_n)^{2}+(y-y_n)^{2}}\n{{\u003c/katex\u003e}}\n\nI added multiple of these terms together to generate a composite map of the NEATO's surroundings. If the term is *positive*, then we get a \"sink\", and if the term is *negative* we get a \"source\". When it comes time for the NEATO to choose a path with gradient descent, it will be attracted to the sinks and repelled from the sources.\n\nI took three different approaches to generating the sinks and sources. First, I just use the endpoints of the best fit lines as sources and the center of the circle as sinks. The issue with this was that on big lines, the NEATO would find paths through the middle of a wall, and would then collide with said wall.\n\nThe next thing I tried was having *n* points between the two endpoints of every line and making each of those sources. The problem there was in the density of sources. Longer lines, like the boundary of the Gauntlet, would have points spaced out every .25 meters, but short lines like the edge of a box would have points spaced out every .025 meters. This was an issue because boundaries need to all have the same weights or else the ones with less weight/density will be treated as acceptable for finding paths.\n\nThe final, successful, approach I took was instead calculating the length of the lines and generating a set of equally spaced points along the line to create sources. For the circle, I found equally spaced points around the circumference.\n\nThe final equation was:\n\n...complicated. I like to embed mathematics with {{\u003ckatex\u003e}}{\\KaTeX}{{\u003c/katex\u003e}}, as you will see above. I knew the equation had a lot of sources and sinks (around 20,000), so instead of manually writing it all out, I wrote a Python script to automate it for me. In [mathtex.py](https://github.com/jack-greenberg/qea-gauntlet/blob/master/mathtex.py) I import all the sources and sinks from CSV files and process them into LaTeX. My thinking was that I would then copy the result into Overleaf, a LaTeX compiler, but when I tried pasting into Overleaf, it said there was an error, and then my browser crashed. If you'd like to view the raw LaTeX, you can run `python3 mathtex.py` or you can look at the CSV files to see the points for yourself.\n\n\n\n### Gradient Descent\n\nAfter I generated the equation, it was time to get the NEATO to actually move. In order to do this, I used a *gradient descent* method. The algorithm works by assessing the current position of the NEATO using ROS's `/odom` topic (which gets the position of the NEATO and it's orientation in the form of a quaternion), rotating in the opposite direction of the gradient vector at its current point, and then moving along some proportion of the length of the gradient vector.\n\nThe equation to calculate the next point is:\n\n{{\u003ckatex display \u003e}}\nr_{n+1} = r_{n} - \\lambda_{n} \\cdot \\nabla V\n{{\u003c/katex\u003e}}\n\nwhere {{\u003ckatex\u003e}} \\lambda_{n} {{\u003c/katex\u003e}} is a scalar and determined by {{\u003ckatex\u003e}}\\lambda_{n-1} = \\delta \\lambda_{n}{{\u003c/katex\u003e}} and {{\u003ckatex\u003e}}\\delta{{\u003c/katex\u003e}} is some scalar. The code to make the NEATO rotate is as follows:\n\n```matlab\nfunction rotate(theta)\n    global pubvel message stopMessage\n    % pubvel is the ROS publisher for /raw-vel\n    % message is a ROS Message used for sending wheel speeds\n    % stopMessage is a ROS Message with wheel speeds of 0 used to\n    %   stop the NEATO\n\n    wheel_speed = .2;\n    wheel_base = 0.235; % Distance between the NEATO's wheels\n\n\t% To make the NEATO rotate, we get the sign of the angle and multiply the\n\t% left wheel by -1 to make the wheels rotate in opposite directions.\n    message.Data = [-1*sign(theta)*wheel_speed, sign(theta)*wheel_speed];\n    send(pubvel, message);\n\n\t% This next chunk uses the elapsed time from the start with the NEATO's\n\t% angular velocity to determine when to stop.\n    start = rostime('now');\n    while (1)\n        current = rostime('now');\n        elapsed = current - start;\n\n        if elapsed.seconds \u003e= abs(theta/(2*wheel_speed / wheel_base))\n            send(pubvel, stopMessage);\n            break\n        end\n    end\nend\n```\n\nThe code for making the NEATO travel in a straight line is very similar, except the wheels rotate in the same direction:\n\n```matlab\nfunction travel(distance)\n    global pubvel message stopMessage bump_sub\n\n    wheel_speed = .2;\n\n    message.Data = [wheel_speed, wheel_speed];\n    send(pubvel, message);\n\n\tstart = rostime('now');\n    while (1)\n        current = rostime('now');\n        elapsed = current - start;\n\n        % A bump sensor tells the NEATO to stop if it bumps into something.\n        bumpMessage = receive(bump_sub);\n        if any(bumpMessage.Data)\n            send(pubvel, stopMessage);\n            break;\n        end\n\n\n        if elapsed.seconds \u003e= abs(distance/wheel_speed)\n            send(pubvel, stopMessage);\n            break\n        end\n    end\nend\n```\n\nIn the end, the NEATO took approximately 45 seconds to reach its goal. It's slowness is due in part to the slow wheel velocity of 0.2 m/s, and in part because it was doing so much computational work in between each movement.\n\n## Final Video\n\n{{\u003c youtube id=\"NQd-fZsqmDU\" autoplay=\"false\" \u003e}}\n"},{"title":"I2C2","date":"2020-05-11 20:43:04 -0700 -0700","year":"2020","draft":"false","featured":"false","image":"images/main.svg","permalink":"https://www.jackgreenberg.co/projects/i2c2/index.json","content":"\nI wrote an [implementation of the I2C protocol](https://github.com/jack-greenberg/i2c2) (inter-integrated chip) in C. It taught me a lot about writing and debugging embedded firmware.\n\n\u003c!--more--\u003e\n\nI2C is a two-wire communication protocol, often used to foster communication between sensors and microcontrollers. I wrote the library for AVR chips, in particular the ATMega328p and ATMega16M1.\n\nIn a nutshell, the protocol works by using one wire as a clock signal (SCL) which then synchronizes the sender and receiver, and one wire as the data signal that transmits 8 bit messages with error handling.\n\n## Motivation\n\nThere were two motivations for the project:\n\n1. The electrical subteam for Olin Electric Motorsports, my school's FSAE team, needed a microcontroller-agnostic I2C library to allow the ATMega16M1 (which has no I2C integration) to communicate with a sensor that outputs I2C, and\n2. I chose the previous reason as motivation for my Software Systems course project.\n\nAdditionally, I am very interested in the interface between hardware and software, and I wanted to teach myself more. Physical layer communication protocols like I2C, SPI, and CAN are very widely used and underlie a lot of the technology we use today, especially the internet.\n\n\n## Implementation\n\nThe library consisted of 3 files: `i2c.c` (the library), `i2c.h` (the header file), and a `Makefile`, as well as a testing file `main.c`. The header file contained constants for things like the microcontroller pins, clock speeds, and read/write mode indicators. The makefile included scripts for compiling and flashing the testing file on an Arduino as well as a script for generating a library file (`i2c.a`).\n\nThe main file of interest though is `i2c.c`, which contains the bulk of the code. The most difficult piece of the implementation was working on synchronization of the SCL and SDA lines. Because embedded C is so low level, it can be difficult to determine the state of a pin on a microcontroller[^1]. So I developed a simple \"stalling\" method that would suspend the program until there was a change in one of the pins:\n\n[^1]: Microcontroller pins control the SDA and SCL lines.\n\n```c\n// Wait while SCL is high (set)\nwhile(bit_is_set(PINB, SCL));\n\n/* Do stuff here while SCL is low */\n\n// Wait while SCL is low (clear)\nwhile (bit_is_clear(PINB, SCL));\n```\n\nThis ended up being one of the most useful idioms in the library, because it allowed me to control when the SDA pin would change state, since according to the I2C spec it is only allowed to change when the SCL line is low.\n\n### Physical Setup\n\nBecause I2C uses open-drain/open-collector set up, it requires pull-up resistors on each line:\n\n{{\u003c img src=\"images/i2c-schematic.png\" caption=\"I2C schematic with pull-up resistors.\" \u003e}}\n\nTo develop the library, I used an Arduino, which uses an ATMega328p microcontroller, and an Analog Discovery, which is essentially a pocket-sized oscilloscope and signal interpreter. I learned about I2C using [Texas Instruments's I2C application report](https://www.ti.com/lit/an/slva704/slva704.pdf). I tested things like signal synchronization and clock frequency settings using the Analog Discovery's oscilloscope, which generated results like this:\n\n{{\u003c img src=\"images/i2c-1.png\" caption=\"Oscilloscope reading of electrical signal: \\\u003cSTART\u003e11101\\\u003cSTOP\u003e\" \u003e}}\n\n### Debugging\n\nOne of the hardest tasks in software, and in particular firmware, is debugging. Ordinarily, when I write Python or Go, there are semi-useful error messages that get printed out to a terminal with tracebacks that help you identify the origin of error. However, when you have no error messages, and instead are just looking at the readout of an oscilloscope, it can often be difficult to find your error source, especially while things are happening at high frequencies like 100kHz. So over time I developed debugging methods and strategies that would help me find sources of error.\n\nMy primary method was making single change to the code and looking for changes in the signal. These changes could be slight, like switching the order that two lines rise from a 0 state to a 1 state, or drastic, like the entire signal stuck in one, unchanging state. This debugging technique was especially useful when it came to synchronization issues, because it was sometimes difficult to tell whether or not I needed to stall while a line was high or a line was low.\n\nFor higher level issues, like figuring out--conceptually--how to enforce a start condition, it is also helpful to talk out loud to a friend.\n\n## Looking back\n\nThe project is not yet complete, and may remain on hold for a month or so. I nearly finished the primary-\u003esecondary[^2] communication channel, I just had issues pertaining to the inner mechanics of the ATMega328P pins.\n\n[^2]: i.e. master-\u003eslave.\n\nI learned a lot about embedded systems from this project. I learned about timers on AVR chips and how different modes (i.e. PWM, CTC) can be useful in different settings. One of the most important lessons I learned was how to read a datasheet. Datasheets are long documents (on the order of hundreds of pages) that detail the usage, mechanics, and properties of electrical components. I spent a lot of time reading [the ATMega328P datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf).\n\nHaving started as a web developer, slowly making my way down the stack until I hit the physical layer has been an amazing and enlightening progression, and I feel that I have a firmer grasp on how the computer systems of the modern world work.\n\n## Looking forward\n\nIn the future I will be picking this project back up and finishing it. I need to work out the `READ` mode (for secondary-\u003eprimary communication) and work on error handling with the `read_ACK_NACK` function.\n"},{"title":"Shutdown Sense Circuit","date":"2020-05-11 18:20:40 -0700 -0700","year":"2020","draft":"false","featured":"false","image":"images/main.svg","permalink":"https://www.jackgreenberg.co/projects/shutdown-sense/index.json","content":"\nThe shutdown sense board is a PCB[^1] on the [Olin Electric Motorsports](https://www.olinelectricmotorsports.com) Mark V car. It provides a helpful diagnostic interface for debugging the shutdown circuit and helps engineers quickly identify sources of failure for the car.\n\n[^1]: Printed circuit board\n\n## The Shutdown Circuit\n\nThe shutdown circuit is the primary safety checking circuit of the car, and runs around the entire body of the vehicle. It controls the the AIRs, or _accumultors isolation relays_, which allow high voltage (~400V nominal) from the accumulator[^2] to flow to the motor controller. However, in the circuit there is a series of nodes at which different conditions in the car could cause the circuit to open, preventing the car from driving. The different parts of the circuit (in order) are:\n\n[^2]: Battery :battery:\n\n1. :key: __GLVMS__: Grounded Low Voltage Master Switch (key to control low voltage)\n2. :red_circle: __ESTOP Left/Right__: Emergency stop buttons on the sides of the car\n3. [__BSPD  ↪__](/projects/bspd/)\n4. :collision: __Inertia Switch__: aka _Crash sensor_\n5. :nut_and_bolt: __BOTS__: Break-over-travel switch, which detects if the break isn't working because it is allowed to be pushed passed the hard-breaking limit\n6. :red_circle: __Cockpit ESTOP__: Driver emergency stop button, aka the _oh shit_ switch\n7. :electric_plug: __HVD__, __Connector to HVD__, __Main Pack Connector__: Various connectors that be used to physically isolate the accumulator from the rest of the car\n8. :battery: __IMD__:  Insulation monitoring device, makes sure the high voltage and low voltage systems are isolated from each other\n9. :key: __TSMS__: Tractive System Master Switch (key to control high voltage)\n\nHere is a more detailed diagram of the shutdown circuit drafted by a previous electrical lead:\n\n{{\u003cimg\n    src=\"images/diagram.png\"\n\u003e}}\n\n## Monitoring the circuit\n\nThe main reason for this working on this project was to provide a simple tool for visualising the status of the shutdown circuit. The majority of the nodes are monitored on boards elsewhere on the car (usually close to the node itself). The two exceptions are the __GLVMS__ and the __Left and Right ESTOPS__. Monitoring for those happens on this board, as you can see towards the left side of the board[^3]:\n\n[^3]: Where the thick wires lead to\n\n{{\u003cimg\n    src=\"images/layout.png\"\n\u003e}}\n\nMonitoring the shutdown circuit at a node works by using a MOSFET transistor is connected to the shutdown circuit _just after the node it is monitoring_, and so if that node opens, the corresponding light will turn off, and the microcontroller on the board registers the change and sends a message to the cars CAN bus (communication network).\n\n### Use case for the board\n\n\u003e Imagine seeing the car on the racetrack and it suddenly stops. There is no explosion, but there are also no more red flashes from the _tractive system active light_, which indicates that high voltage is flowing from the battery to the motor controller. Instead of manually checking each node, you can pop open the LV Box where this board is located and quickly see where the circuit opened, get the issue fixed, and get wheels spinning again.\n\n## Looking back\n\nThis project was a lot of fun because of its simplicity. It is basically just a lot of LEDs in a row, and so it allowed for a lot of creativity in the \"UX\" of the board, namely for the silk screen (used for labeling on the board).\n\nThis board also taught me a lot about debugging. When we shipped the first revision of the board from the PCB manufacturer, I forgot to run the DRC, or _design rules check_, which, had it been run, would have warned me that I had some missing wires. The biggest blunder I made was forgetting to ground my microcontroller, which led to it behaving erratically. Discovering this took a lot of time combing over each part of the board with a voltmeter, and re-soldering the microcontroller _two_ times. Despite the frustrations, it did teach me a lot in the end, and it was all worth it.\n\nSince we had to evacuate campus due to the pandemic, we never were able to ship the second revision of the board, but as soon as it is safe to do it, I am excited to receive it, hook it up to the car, and watch it do its thing.\n\n{{\u003cimg\n    src=\"images/render.png\"\n    caption=\"A 3D render of the board\"\n\u003e}}\n"},{"title":"BSPD Brakelight Circuit","date":"2020-05-11 18:20:30 -0700 -0700","year":"2020","draft":"false","featured":"false","image":"images/main.svg","permalink":"https://www.jackgreenberg.co/projects/bspd/index.json","content":"\nMy first project for [Olin Electric Motorsports](https://www.olinelectricmotorsports.com) was redesigning the mission-critical _brake system plausibility device_. The analog circuit controls one node of the shutdown circuit on the car, helping to ensure the safety of the driver and vehicle.\n\n\u003c!-- more --\u003e\n\n## How to PCB\n\nThe final deliverable for this project was a PCB, or printed circuit board, which would slot into the car's low voltage box. Along with performing a critical safety check for the electrical systems during racing, the circuit also handles activating the brakelight based on the reading of an brake pressure sensor. Understanding the project was the first--and one of the hardest--tasks I had to accomplish.\n\n### Brake System Plausibility\n\nThe brake system plausibility device (BSPD) is an analog circuit that provides a critical safety check for the car. It ensures that the motor controller isn't supplying current to the motor while the brake is being pressed. This condition is dangerous because it means the driver has lost control of the car, and so it causes the car to shut down.\n\nIn ordinary conditions, the throttle circuit (which is responsible for making the car accelerate) should prevent this from happening, but in the event that that doesn't happen, the BSPD circuit is a backup.\n\nThe circuit operates on a fairly simple AND gate to check for the condition, and implements a set-reset latch to ensure that the car cannot begin moving again until it is power-cycled[^1].\n\n[^1]: Power-cycling -\u003e turn off and on again.\n\n### Brakelight\n\nThe other parts of the circuit are the brakelight circuit, which reads an analog signal from a brake pressure sensor and activates the brakelight if it is above a certain threshold, and triggers a low-side drive that turns on the brakelight.\n\n## Learning the Ropes\n\nThis was my first serious electrical engineering project. When I started, my only experience was my AP Physics course, and we didn't do anything even close to this.\n\nThe first step in a project like this is understanding the target. This took me a long time because I had very little concept of how the car worked. Over time, I picked up bits and pieces and finally began to understand what this circuit needed to do. So the next step was creating a schematic.\n\n{{\u003cimg\n    src=\"images/schematic.png\"\n    caption=\"BSPD/Brakelight circuit schematic.\"\n\u003e}}\n\nSchematics are the way electrical engineers detail the components that go on a board, like the resistors, integrated chips (microcontrollers), and LEDs. I broke up the schematic for this board into functional blocks: BSPD, brakelight, buck converter[^2], microcontroller, connector, and a few other bits and pieces.\n\n[^2]: Buck converters are switch-mode power supplies that can reduce an input voltage.\n\nAfter finishing a schematic and getting it reviewed, I began work on the layout. The layout is the design of the actual printed circuit board (PCB). It reads the schematic to figure out what components will go on the board, and then it is the responsibility of the designer to lay out the components and the wires between them such that everything is connected and works efficiently.\n\n{{\u003cimg\n    src=\"images/layout.png\"\n    caption=\"BSPD/Brakelight circuit layout.\"\n\u003e}}\n\n## Looking Back\n\nThis project was left in a strange state. I had just finished the layout and gotten it reviewed by the senior engineers on the FSAE team when all the students at Olin were ordered to vacate the campus due to concerns about COVID-19. I was able to ship one revision of the board and test it, and it worked as expected, but until we are back on campus and with the car, we won't be able to ship the most recent version and test with the car.\n"}]}